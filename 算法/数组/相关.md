# 数组相关
## 初始化数组
1. 一维数组：
```js
var arr = new Array(7).fill('1')
```
2. 二维数组：
注意初始化二维数组时不要使用fill来填充，因为给fill传递一个入参时，如果该参数是引用类型，那么在填充时就是填充的是参数的引用地址；所以这样二维的数组就所有共用一个引用地址了；所以建议使用for循环来初始化一个二维数组
```js
const len = arr.length
for(let i=0;i<len;i++) {
    arr[i] = []
}
```

## 栈和队列
### 数组中增删操作
- 增加
unshift
push
splice
- 删除
shift
pop
splice
### 栈
数组使用push和pop实现
先进后出、只允许从尾部添加和移除元素
### 队列
数组使用push和shift实现
先进先出、只允许从尾部添加元素和头部移除元素

## 链表
链表和数组相似，都是有序的列表及线性的结构（有且只有一个前驱和一个后继），不同点在于数据单位的名称为“结点”
链表中，每一个结点的结构都包括了两部分的内容：数据域和指针域，通过JS内嵌对象的形式来实现:
```js
{
  val: 1, // 数据域
  next: { // 指针域
    val: 2,
    next: ...
  }
}
```
数据域存储的是当前结点所储存的数据值；
指针域存储的是下一个结点的引用；
要想访问链表中的任何一个元素，就需要从起点结点开始，逐个访问next，一直访问到目标结点为止；为了确保起点结点是可抵达的，我们一般会设定一个head指针来专门指向链表的开始位置；
- 生成结点构造函数
```js
function ListNode(val) {
  this.val = val
  this.next = null
}
```

### 链表元素的增加
尾部添加新结点
两结点之间插入新结点：
```js
const head = new ListNode(null)
const node1 = new ListNode(1)
const node2 = new ListNode(2)
head.next = node1
node1.next = node2
const node3 = new ListNode(3)
// 1，2结点之间插入3结点
node3.next = node1.next
node1.next = node3
```

### 链表元素的删除

### 数组和链表的辨析
JS中数组不一定是真正意义上的数组：
```js
const arr1 = [1, 2, 3, 4] // 真正数组
const arr2 = ['haha', 1, {a:1}] // 非真正数组
```
真正的数组：存储在连续的内存空间里

由于数组内部的元素存储在连续的内存空间里，那么如果在中间插入元素的话，新插入的元素后面的元素就要往后排，删除则反之；时间复杂度为`O(n)`
链表相对于数组而言，有一个明显的优点就是高效的的增删操作，时间复杂度为`O(1)`
但是链表有个弊端就是访问效率比较低，必须要进行遍历来访问，假设我们需要访问第10位置的结点的话，就需要：
```js
let length = 10
let node = head
for(let i=0;i<length&&node;i++) {
  node = node.next
}
```
总结：数组的优点在于数组某个元素的获取，缺点在于元素的增删操作比较耗费性能；链表的优点在于结点的增删操作比较高效，缺点在于获取结点的操作比较耗费性能；

## 树
### 基本概念
树的层次计算规则：根节点所在的为第一层，其子节点

### 二叉树

### 二叉树的遍历

先序遍历：根结点点->左子树->右子树
中序遍历：左子树->根结点->右子树
后序遍历：左子树->右子树->根结点
层次遍历

所谓先中后序是根据根结点的遍历时机来定义的


